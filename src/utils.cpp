#include "pch.h"
#include "utils.h"

const qreal Utils::PI = 3.14159265358979323846;
const qreal Utils::EPS = 0.0001;

qreal Utils::sign(qreal x)
{
	if (x > 0.0)
		return 1.0;
	if (x < 0.0)
		return -1.0;
	return 0.0;
}

qreal Utils::radToDeg(qreal angle)
{
	return angle * 180.0 / PI;
}

qreal Utils::degToRad(qreal angle)
{
	return angle * PI / 180.0;
}

bool Utils::isEqual(qreal value1, qreal value2, qreal eps)
{
	return qAbs(value1 - value2) <= eps;
}

QString Utils::addTrailingSlash(const QString &path)
{
	return !path.endsWith('/') && !path.endsWith('\\') ? path + '/' : path;
}

bool Utils::isFileNameValid(const QString &fileName)
{
	QRegExp regexp("([a-z][a-z\\d_]*/)*[a-z][a-z\\d_]*\\.[a-z]+");
	return regexp.exactMatch(fileName);
}

bool Utils::isFileNameValid(const QString &fileName, const QString &dir, QWidget *parent)
{
	// проверяем, что имя не пустое
	if (fileName.isEmpty())
		return false;

	// проверяем, что файл находится в заданном каталоге
	if (!fileName.startsWith(dir))
	{
		QMessageBox::warning(parent, "", "Неверный путь к файлу " + fileName + "\nВы можете работать с файлами только внутри папки " + dir);
		return false;
	}

	// проверяем относительный путь к файлу на валидность
	QString relativePath = fileName.mid(dir.size());
	if (!isFileNameValid(relativePath))
	{
		QMessageBox::warning(parent, "", "Неверный путь к файлу " + relativePath + "\nПереименуйте файлы и папки так, чтобы они "
			"начинались с буквы и состояли только из маленьких латинских букв, цифр и знаков подчеркивания");
		return false;
	}

	return true;
}

QString Utils::toCamelCase(const QString &fileName)
{
	// заменяем все вхождения символа '_' и строчной буквы на одну заглавную букву
	QString name = QFileInfo(fileName).baseName();
	QString str;
	for (int i = 0; i < name.size(); ++i)
		str += name[i] == '_' && i < name.size() - 1 ? name[++i].toUpper() : name[i];
	return str;
}

QString Utils::toPascalCase(const QString &fileName)
{
	// конвертируем строку в стиль Camel и меняем первую букву на заглавную
	QString str = toCamelCase(fileName);
	if (!str.isEmpty())
		str[0] = str[0].toUpper();
	return str;
}

bool Utils::fileExists(const QString &path)
{
	// проверяем, что файл существует с точностью до регистра символов
	if (QFile::exists(path))
	{
		QFileInfo fileInfo(path);
		return fileInfo.dir().entryList().contains(fileInfo.fileName());
	}

	return false;
}

QString Utils::quotify(const QString &text)
{
	// вставляем обратный слэш перед одинарными и двойными кавычками, а также перед самим обратным слэшем
	QString str;
	foreach (QChar ch, text)
	{
		if (ch == '\'' || ch == '\"' || ch == '\\')
			str += '\\';
		str += ch;
	}
	return "\"" + str + "\"";
}

std::string Utils::toStdString(const QString &str)
{
	return QTextCodec::codecForName("System")->fromUnicode(str).data();
}

std::wstring Utils::toStdWString(const QString &str)
{
#ifdef _MSC_VER
	return std::wstring(reinterpret_cast<const wchar_t *>(str.utf16()));
#else
	return str.toStdWString();
#endif
}

void Utils::writeFileHeader(QTextStream &stream)
{
	stream << "-- *****************************************************************************" << endl;
	stream << "-- This file was automatically generated by " << QCoreApplication::applicationName() << " editor." << endl;
	stream << "-- All changes made in this file will be lost. DO NOT EDIT!" << endl;
	stream << "-- *****************************************************************************" << endl;
}
